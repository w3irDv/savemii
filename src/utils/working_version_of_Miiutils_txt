#include <ctime>
#include <menu/MiiTypeDeclarations.h>

#include <mii/MiiFolderRepo.h>
#include <mii/WiiMii.h>
#include <mii/WiiUMii.h>
#include <utils/Colors.h>
#include <utils/ConsoleUtils.h>
#include <utils/DrawUtils.h>
#include <utils/InProgress.h>
#include <utils/MiiUtils.h>

bool MiiUtils::initMiiRepos() {

    const std::string pathffl("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_FFL");
    const std::string pathffl_Stage("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_FFL_Stage");
    const std::string pathrfl("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_RFL");
    const std::string pathrfl_Stage("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_RFL_Stage");
    const std::string pathaccount("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_ACCOUNT");
    const std::string pathaccount_Stage("fs:/vol/external01/wiiu/backups/mii_repos/mii_repo_ACCOUNT_Stage");

    MiiRepos["FFL"] = new MiiFolderRepo<WiiUMii, WiiUMiiData>("FFL", MiiRepo::eDBType::FFL, MiiRepo::eDBKind::FOLDER, pathffl, "mii_bckp_ffl");
    MiiRepos["FFL_Stage"] = new MiiFolderRepo<WiiUMii, WiiUMiiData>("FFL_Stage", MiiRepo::eDBType::FFL, MiiRepo::eDBKind::FOLDER, pathffl_Stage, "mii_bckp_ffl_Stage");
    MiiRepos["RFL"] = new MiiFolderRepo<WiiMii, WiiMiiData>("RFL", MiiRepo::eDBType::RFL, MiiRepo::eDBKind::FOLDER, pathrfl, "mii_bckp_rfl");
    MiiRepos["RFL_Stage"] = new MiiFolderRepo<WiiMii, WiiMiiData>("RFL_Stage", MiiRepo::eDBType::RFL, MiiRepo::eDBKind::FOLDER, pathrfl_Stage, "mii_bckp_rfl_Stage");
    MiiRepos["ACCOUNT"] = new MiiFolderRepo<WiiUMii, WiiUMiiData>("ACCOUNT", MiiRepo::eDBType::ACCOUNT, MiiRepo::eDBKind::FOLDER, pathaccount, "mii_bckp_account");
    MiiRepos["ACCOUNT_Stage"] = new MiiFolderRepo<WiiUMii, WiiUMiiData>("ACCOUNT_Stage", MiiRepo::eDBType::ACCOUNT, MiiRepo::eDBKind::FOLDER, pathaccount_Stage, "mii_bckp_account_Stage");

    MiiRepos["FFL"]->setStageRepo(MiiRepos["FFL_Stage"]);
    MiiRepos["FFL_Stage"]->setStageRepo(MiiRepos["FFL"]);

    MiiRepos["RFL"]->setStageRepo(MiiRepos["RFL_Stage"]);
    MiiRepos["RFL_Stage"]->setStageRepo(MiiRepos["RFL"]);

    MiiRepos["ACCOUNT"]->setStageRepo(MiiRepos["ACCOUNT_Stage"]);
    MiiRepos["ACCOUNT_Stage"]->setStageRepo(MiiRepos["ACCOUNT"]);

    mii_repos = {MiiRepos["FFL"], MiiRepos["FFL_Stage"], MiiRepos["RFL"], MiiRepos["RFL_Stage"], MiiRepos["ACCOUNT"], MiiRepos["ACCOUNT_Stage"]};

    return true;
}


std::string MiiUtils::epoch_to_utc(int temp) {
    const time_t old = (time_t) temp;
    struct tm *oldt = gmtime(&old);
    char buffer[11];
    strftime(buffer, 80, "%Y-%m-%d", oldt);
    return std::string(buffer);
}


bool MiiUtils::export_miis(uint8_t &errorCounter, MiiProcessSharedState *mii_process_shared_state) {
    auto mii_repo = mii_process_shared_state->primary_mii_repo;
    auto mii_view = mii_process_shared_state->primary_mii_view;
    auto c2a = mii_process_shared_state->primary_c2a;

    MiiRepo *target_repo = mii_repo->stage_repo;
    if (target_repo == nullptr) {
        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Target repo is null"));
        return false;
    }
    
    if (mii_view == nullptr || c2a == nullptr || mii_repo == nullptr) {
        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Aborting Transform - MiiProcesSharedState is not completely initialized"));
        return false;
    }

    auto candidate_miis_count = c2a->size();

    InProgress::totalSteps = 0;
    InProgress::currentStep = 1;
    InProgress::abortTask = false;

    for (size_t i = 0; i < candidate_miis_count; i++) {
        if (mii_view->at(c2a->at(i)).selected)
            InProgress::totalSteps++;
    }

    for (size_t i = 0; i < candidate_miis_count; i++) {
        if (mii_view->at(c2a->at(i)).selected) {
            size_t mii_index = c2a->at(i);
            //showMiiOperations(mii_process_shared_state, c2a->at(i));
            Console::showMessage(OK_SHOW,"%d/%d",i,candidate_miis_count);
            mii_view->at(mii_index).selected = false;
            mii_view->at(mii_index).state = MiiStatus::KO;
            MiiData *mii_data = mii_repo->extract_mii_data(mii_index);
            if (mii_data != nullptr) {
                if (target_repo->import_miidata(mii_data))
                    mii_view->at(mii_index).state = MiiStatus::OK;
                delete mii_data;
            } else {
                Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Error extracting MiiData for %s (by %s)"), mii_repo->miis[mii_index]->mii_name.c_str(), mii_repo->miis[mii_index]->creator_name.c_str());
            }
            if (mii_view->at(mii_index).state == MiiStatus::KO)
                errorCounter++;

            InProgress::currentStep++;
        }
    }
    return (errorCounter == 0);
}

bool MiiUtils::import_miis(uint8_t &errorCounter, MiiProcessSharedState *mii_process_shared_state) {

    auto mii_repo = mii_process_shared_state->auxiliar_mii_repo;
    auto mii_view = mii_process_shared_state->auxiliar_mii_view;
    auto c2a = mii_process_shared_state->auxiliar_c2a;
    auto candidate_miis_count = c2a->size();

    auto receiving_repo = mii_process_shared_state->primary_mii_repo;

    if (receiving_repo == nullptr) {
        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Receiving repo is null"));
        return false;
    }

    InProgress::totalSteps = 0;
    InProgress::currentStep = 1;
    InProgress::abortTask = false;
    for (size_t i = 0; i < candidate_miis_count; i++) {
        if (mii_view->at(c2a->at(i)).selected)
            InProgress::totalSteps++;
    }

    for (size_t i = 0; i < candidate_miis_count; i++) {
        if (mii_view->at(c2a->at(i)).selected) {
            size_t mii_index = c2a->at(i);
            //showMiiOperations(mii_process_shared_state, c2a->at(i));
            Console::showMessage(OK_SHOW,"%d/%d -- miiindex %d ",i,candidate_miis_count,mii_index);
            mii_view->at(mii_index).selected = false;
            mii_view->at(mii_index).state = MiiStatus::KO;
            Console::showMessage(ERROR_SHOW,"DBG -jo no crec que arrivi aqui - %d/%d -- miiindex %d ",i,candidate_miis_count,mii_index);
            MiiData *mii_data = mii_repo->extract_mii_data(mii_index);
            if (mii_data != nullptr) {
                if (receiving_repo->import_miidata(mii_data))
                    mii_view->at(mii_index).state = MiiStatus::OK;
                delete mii_data;
            } else
                Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Error extracting MiiData for %s (by %s)"), mii_repo->miis[mii_index]->mii_name.c_str(), mii_repo->miis[mii_index]->creator_name.c_str());
            if (mii_view->at(mii_index).state == MiiStatus::KO)
                errorCounter++;

            InProgress::currentStep++;
            if (InProgress::totalSteps > 1) { // It's so fast that is unnecessary ...
                InProgress::input->read();
                if (InProgress::input->get(ButtonState::HOLD, Button::L) && InProgress::input->get(ButtonState::HOLD, Button::MINUS)) {
                    InProgress::abortTask = true;
                }
            }
        }
    }
    return (errorCounter == 0);
}

// show InProgress::currentStep mii
void MiiUtils::showMiiOperations(MiiProcessSharedState *mii_process_shared_state, size_t mii_index) {

    MiiRepo *source_mii_repo = nullptr;
    MiiRepo *target_mii_repo = nullptr;

    switch (mii_process_shared_state->state) {
        case MiiProcess::SELECT_MIIS_FOR_IMPORT:
            source_mii_repo = mii_process_shared_state->auxiliar_mii_repo;
            target_mii_repo = mii_process_shared_state->primary_mii_repo;
            break;
        default:
            source_mii_repo = mii_process_shared_state->primary_mii_repo;
            target_mii_repo = mii_process_shared_state->auxiliar_mii_repo;
    }

    DrawUtils::beginDraw();
    DrawUtils::clear(COLOR_BACKGROUND);
    DrawUtils::setFontColor(COLOR_INFO);

    Console::consolePrintPos(-2, 6, ">> %s (by %s)", source_mii_repo->miis[mii_index]->mii_name.c_str(), source_mii_repo->miis[mii_index]->creator_name.c_str());
    Console::consolePrintPosAligned(6, 4, 2, "%d/%d", InProgress::currentStep, InProgress::totalSteps);
    DrawUtils::setFontColor(COLOR_TEXT);
    Console::consolePrintPos(-2, 8, LanguageUtils::gettext("Copying from: %s"), source_mii_repo->repo_name.c_str());
    Console::consolePrintPos(-2, 11, LanguageUtils::gettext("To: %s"), target_mii_repo->repo_name.c_str());
    if (InProgress::totalSteps > 1) {
        if (InProgress::abortTask) {
            DrawUtils::setFontColor(COLOR_LIST_DANGER);
            Console::consolePrintPosAligned(17, 4, 2, LanguageUtils::gettext("Will abort..."));
        } else {
            DrawUtils::setFontColor(COLOR_INFO);
            Console::consolePrintPosAligned(17, 4, 2, LanguageUtils::gettext("Abort:\ue083+\ue046"));
        }
    }
    DrawUtils::endDraw();
}

void MiiUtils::xfer_attribute(MiiProcessSharedState *mii_process_shared_state) {

    auto mii_repo = mii_process_shared_state->primary_mii_repo;
    auto mii_view = mii_process_shared_state->primary_mii_view;
    auto c2a = mii_process_shared_state->primary_c2a;
    auto candidate_miis_count = c2a->size();
    auto template_mii_data = mii_process_shared_state->template_mii_data;


    if (mii_view != nullptr && c2a != nullptr && mii_repo != nullptr) {
        for (size_t i = 0; i < candidate_miis_count; i++) {
            if (mii_view->at(c2a->at(i)).selected) {
                size_t mii_index = c2a->at(i);
                mii_view->at(mii_index).state = MiiStatus::KO;
                MiiData *mii_data = mii_repo->extract_mii_data(mii_index);
                if (mii_data != nullptr) {
                    if (mii_process_shared_state->transfer_ownership)
                        mii_data->transfer_ownership_from(template_mii_data);
                    if (mii_process_shared_state->transfer_physical_appearance)
                        mii_data->transfer_appearance_from(template_mii_data);
                    if (mii_process_shared_state->primary_mii_repo->import_miidata(mii_data))
                        mii_view->at(mii_index).state = MiiStatus::OK;
                    else
                        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Error importing Mii %s in repo %s"), mii_process_shared_state->primary_mii_repo->miis[mii_index]->mii_name.c_str(), mii_process_shared_state->primary_mii_repo->repo_name.c_str());
                    delete mii_data;
                } else
                    Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Error extracting MiiData for %s (by %s)"), mii_repo->miis[mii_index]->mii_name.c_str(), mii_repo->miis[mii_index]->creator_name.c_str());
            }
        }
    } else {
        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Aborting Transform - MiiProcesSharedState is not completely initialized"));
    }
};

void MiiUtils::set_copy_flag_on(MiiProcessSharedState *mii_process_shared_state) {

    auto mii_repo = mii_process_shared_state->primary_mii_repo;
    auto mii_view = mii_process_shared_state->primary_mii_view;
    auto c2a = mii_process_shared_state->primary_c2a;
    auto candidate_miis_count = c2a->size();

    if (mii_view != nullptr && c2a != nullptr && mii_repo != nullptr) {
        for (size_t i = 0; i < candidate_miis_count; i++) {
            if (mii_view->at(c2a->at(i)).selected) {
                size_t mii_index = c2a->at(i);
                mii_view->at(mii_index).state = MiiStatus::KO;
                MiiData *mii_data = mii_repo->extract_mii_data(mii_index);
                if (mii_data != nullptr) {
                    mii_data->set_copy_flag();
                    if (mii_repo->import_miidata(mii_data))
                        mii_view->at(mii_index).state = MiiStatus::OK;
                    delete mii_data;
                } else
                    Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Error extracting MiiData for %s (by %s)"), mii_repo->miis[mii_index]->mii_name.c_str(), mii_repo->miis[mii_index]->creator_name.c_str());
            }
        }
    } else {
        Console::showMessage(ERROR_SHOW, LanguageUtils::gettext("Aborting Transform - MiiProcesSharedState is not completely initialized"));
    }
};
